## nginx进程模型

nginx后台进程包含一个master进程和多个worker进程
**多进程**的工作模式
基本的网络事件，主要在worker进程中处理
一般我们会设置worker进程数与机器的cpu核数一致。因为更多的worker只会导致进程之间相互竞争cpu，从而带来不必要的上下文切换。

一个请求，完全由worker进程来处理，而且只在一个worker进程中处理。

## worker进程工作流程

当一个 worker 进程在 accept() 这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，一个完整的请求。一个请求，完全由worker进程来处理，而且只会在一个worker进程中处理。

这样做带来的好处：

1、独立的进程省掉了锁开销。每个worker进程都彼此独立地工作，不共享任何资源，因此不需要锁。同时在编程以及问题排查上时，也会方便很多。

2、采用独立的进程，相互之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快重新启动新的worker进程。当然，worker进程自己也能发生意外退出。

## Nginx采用的 IO多路复用模型epoll

多路复用，允许我们只在事件发生时才将控制返回给程序，而其他时候内核都挂起进程，随时待命。

epoll通过在Linux内核中申请一个简易的文件系统（文件系统一般用B+树数据结构来实现）

一个进程里**只有一个线程**，所以一个进程同时只能做一件事，但是可以通过不断地切换来“同时”处理多个请求。

例子：Nginx 会注册一个事件：“如果来自一个新客户端的连接请求到来了，再通知我”，此后只有连接请求到来，服务器才会执行 accept() 来接收请求。又比如向上游服务器（比如 PHP-FPM）转发请求，并等待请求返回时，这个处理的 worker 不会在这阻塞，它会在发送完请求后，注册一个事件：“如果缓冲区接收到数据了，告诉我一声，我再将它读进来”，于是进程就空闲下来等待事件发生。

基于 **多进程+epoll**， Nginx 便能实现高并发。

## nginx 如何处理事件

nginx采用异步非阻塞的方式处理事件。

