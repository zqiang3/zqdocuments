git是以指针为基础
在提交时，git创建一个包含提交消息和相关数据的文件，并将其链接到一个树形文件，树形文件包含一个对象列表或者其他树，对象或二进制大数据对象是提交的真正内容，所有这些文件都以对象的SHA-1哈希为文件名进行存储。分支和标签只是一些文件，这些文件包含一个指身提交的SHA-1哈希值。使用这些引用在灵活性和速度上均有大幅提升，创建一个新的分支就和创建一个文件一样简单。

所有的分支指针保存在.git/refs/heads目录下，HEAD在.git/HEAD目录下，标签在.git/refs/tags目录下

app_mongodb_config

https://cc.gdl.netease.com/cc-2.3.6(298605).apk

https://weblbs.cc.163.com/android-download


https://mversion.cc.163.com/anversion?version=294552&channel=100&versionname=2.3.5


# git status
执行git status命令时，真正发生了什么呢

依据.git/index中记录的文件时间戳、长度等信息判断工作区文件是否改变。如果时刻戳改变，git需要打开文件，读取文件内容和之前的文件相比较。比较之后，如果发现文件内容没有改变，则记录文件新的时间戳。
判断文件是否更改，使用时间戳、文件长度等信息进行比较要比通过文件内容比较要快的多，所以 Git 这样的实现方式可以让工作区状态扫描更快速的执行，这也是 Git 高效的因素之一。
文件.git/index 实际上就是一个包含文件索引的目录树，像是一个虚拟的工作区。在这个虚拟工作区的目录树中，记录了文件名、文件的状态信息（时间戳、文件长度等），文件的 内容并不存储其中，而是保存在 Git 对象库（.git/objects）中，文件索引建立了文件和对象库中对象实体之间的对应。

# git dd
当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID 被记录在暂存区的文件索引中。

# git commit 
当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。

# git reset HEAD
当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。

# git rm --cached <file>
当执行 “git rm Ccached <file>” 命令时，会直接从暂存区删除文件，工作区则不做出改变。

# git checkout <file>
当执行 “git checkout .” 或者 “git checkout ― <file>” 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。

# git checkout HEAD .
当执行 “git checkout HEAD .” 或者 “git checkout HEAD <file>” 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改 动。
