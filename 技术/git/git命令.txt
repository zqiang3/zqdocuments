# 常用
git status
git checkout test
git pull --rebase
git add
git commit -am
git push origin master
git merge
git log

# 修改远程仓库地址
git remote set-url origin [url]



# 查看所有分支
git branch -a

# 创建分支
git branch test  # 创建test分支
git checkout -b dev   # 创建并切换分支

# 切换分支
git checkout test

# 从远程checkout
git checkout -b feature/some_feature -t origin/feature/some_feature

# 删除本地分支
git branch -d test
-D  # 强制删除

# git push origin master
上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。
如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。

# git push origin :master
等同于
git push origin --delete master

# git push -u origin master
上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了

# git push
不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。

$ git config --global push.default matching
# 或者
$ git config --global push.default simple

# git log
可以加 --pretty=oneline 输出单行日志

# 命令历史
git reflog

# 回退
git reset --hard HEAD^
git reset --hard 3628164
git中，HEAD表示当前版本，上一个版本是HEAD^，上上个版本是HEAD^^，往上100个版本是HEAD~100

# 撤销工作区的修改
git checkout file  # 丢弃工作区的修改,回复到最近一次git commit 或 git add的状态
git checkout 是用版本库里的文件版本替换工作区的版本，无论工作区文件是修改还是删除，都可以还原到版本库的状态。

# 撤销暂存区的修改
git reset HEAD file

# 撤销提交到本地的修改
git reset --hard HEAD^


# git diff
此命令比较的是工作目录和暂存区快照之间的差异，也就是修改之后还没暂存起来的内容

查看已经暂存起来的文件和上次提交时的快照之间HEAD之间的差异
git diff --cached
git diff --staged

显示工作版本和HEAD的差别
git diff HEAD

直接将两个分支上最新的提交做diff
git diff topic master 或 git diff topic..master

查看简单的diff结果，可以加上--stat参数
git diff --stat

比较两个历史版本之间的差异
git diff SHA1 SHA2
# 删除文件
git rm test.txt

# git pull
git pull从远程仓库获取最新版本代码并merge到本地。


# git pull --rebase
我们在使用git pull命令的时候，可以使用--rebase参数，这里表示把你的本地当前分支里的每个提交(commit)取消掉，并且把它们临时保存为补丁(patch)(这些补丁放到".git/rebase"目录中),然后把本地当前分支更新为最新的"origin"分支，最后把保存的这些补丁应用到本地当前分支上。

git config --global branch.autosetuprebase always  # 所有分支在pull时都使用rebase


# git log
git log --graph  可以查看分支合并图
git log --author=
git log --grep="something in the message"
git log --since=2.months.ago --until=1.days.ago

# =======================================================

# 暂存区
.git是Git的版本库
版本库中最重要的就是暂存区（称为stage或index）

git add时把文件修改添加到暂存区
git commit时把暂存区内容提交到当前分支

需要提交的文件通通放到暂存区，然后，一次性提交暂存区的所有修改。

提交后，如果工作区没作任何修改，工作区就是干净的(clean)
nothing to commit (working directory clean)

暂存区是Git非常重要的概念，理解了暂存区是什么，就能明白Git的很多操作到底是在干什么


#回滚代码
如果修改还没提交
git reset HEAD lib/foo.b
如果已经提交了一次
git commit -amend
这将圆滚到上一次的提交
回滚本地代码库
git reset --hard commit_id :回滚到commit_id
git reset --hard HEAD~3：将最近3次的提交回滚

回滚远程代码库
应用场景：自动部署系统发布后发现问题，需要回滚到某一个commit，再重新发布
原理：先将本地分支退回到某个commit，删除远程分支，再重新push本地分支

# git blame
寻找谁更改了一个文件中的一行代码经常会用到
git blame FILE
git blame -c FILE
git gui blame FILE

git的维护
git count-objects -v
垃圾回收重复内容
git gc

操作步骤：

1、git checkout develop && git pull
3、git branch backup_branch //备份一下这个分支当前的情况
4、git reset --hard commit_id//把develop本地回滚到commit_id
5、git push origin :develop//删除远程 develop
6、git push origin develop//用回滚后的本地分支重新建立远程分支
7、git branch -d backup_branch//如果前面都成功了，删除这个备份分支

如果使用了gerrit做远程代码中心库和code review平台，需要确保操作git的用户具备分支的push权限，并且选择了 Force Push选项（在push权限设置里有这个选项）

另外，gerrit中心库是个bare库，将HEAD默认指向了master，因此master分支是不能进行删除操作的，最好不要选择删除master分支的策略，换用其他分支。如果一定要这样做，可以考虑到gerrit服务器上修改HEAD指针。。。不建议这样搞


# 追踪远程分支
 git push --set-upstream origin feature/1102

git branch --set-upstream feature/1102 origin/<branch>

git branch --track branch名Q h端branch 建立一 tracking h端 branch 的 branch，@右葬 push/pull都直接到h端的branch。

# 远程分支关联
使用场景: 本地新建一个分支后，必须要做远程分支关联。如果没有关联，git会在下面的操作中提示你显示的添加关联。关联目的是如果在本地分支下操作： git pull, git push ，不需要指定在命令行指定远程的分支．

git push --set-upstream origin feature/micbrowser
命令的最终修改都是针对config文件

# git push , git pull的默认行为
如果你未曾改动过git config中的push.default属性，根据我们使用的git不同版本（Git 2.0之前或之后），git push通常会有两种截然不同的行为:

develop分支中本地新增的commit被push到远程仓库
push失败，并收到git如下的警告

fatal: The current branch new has no upstream branch.  
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin develop

为什么git版本不同会有两种不同的push行为？

因为在git的全局配置中，有一个push.default属性，其决定了git push操作的默认行为。在Git 2.0之前，这个属性的默认被设为'matching'，2.0之后则被更改为了'simple'。

我们可以通过git version确定当前的git版本（如果小于2.0，更新是个更好的选择），通过git config --global push.default 'option'改变push.default的默认行为（或者也可直接编辑~/.gitconfig文件）。

push.default 有以下几个可选值： 
nothing, current, upstream, simple, matching

其用途分别为：

nothing - push操作无效，除非显式指定远程分支，例如git push origin develop（我觉得。。。可以给那些不愿学git的同事配上此项）。

current - push当前分支到远程同名分支，如果远程同名分支不存在则自动创建同名分支。

upstream - push当前分支到它的upstream分支上（这一项其实用于经常从本地分支push/pull到同一远程仓库的情景，这种模式叫做central workflow）。

simple - simple和upstream是相似的，只有一点不同，simple必须保证本地分支和它的远程 upstream分支同名，否则会拒绝push操作。

matching - push所有本地和远程两端都存在的同名分支。

因此如果我们使用了git2.0之前的版本，push.default = matching，git push后则会推送当前分支代码到远程分支，而2.0之后，push.default = simple，如果没有指定当前分支的upstream分支，就会收到上文的fatal提示。

初次提交本地分支，例如git push origin develop操作，并不会定义当前本地分支的upstream分支，我们可以通过git push --set-upstream origin develop，关联本地develop分支的upstream分支，另一个更为简洁的方式是初次push时，加入-u参数，例如git push -u origin develop，这个操作在push的同时会指定当前分支的upstream