# 中文名

C和指针

# 第一章 快速上手

### 要点

空白和注释：注释不能嵌套

预处理指令

main函数

传址调用与传值调用

字符串与字符串函数

编译：cc test.c

### 警告的总结

1. 使用scanf时未在标量参数前添加&字符
2. 机械地把printf函数的格式代码照搬于scanf函数
3. 在应该使用&&操作符的地方误用了&操作符
4. 测试相等性时误用=操作符，而不是==操作符

### 编程提示的总结

1. 使用#include避免重复声明t
2. 使用#define给常量值取名
3. 在#include文件中放置函数原型
4. 在使用数组下标前，检查下标的值，检查下标是否越界
5. 在while或if表达式中使用赋值操作
6. 空循环体
7. 

# 第二章 基本概念

## 要点

环境：翻译环境（translation environment）和执行环境（execution environment）

编译和链接，执行

词法规则，字符，三字母词

程序风格

### 编程提示的总结

1. 字符串中的常量被错误地解释为三字母词（编译时添加 --trigraphs支持）
2. 编写糟糕的注释可能会意外地中止程序



# 第三章 数据

## 要点

数据类型：整型、浮点类型、指针

整型：char、short int、int和long int，它们都有signed和unsigned两种版本。

char是signed char或者是unsigned char，这取决于编译器的实现。

枚举类型。

浮点数家族：float、double和long double。浮点数字面值缺省情况下是double类型，指定float类型使用f或F，指定long double使用L或l

指针：字符串常量的直接值是一个指向字符的指针。

声明：声明数组，声明指针

typedef

常量：在某些情况下，使用#define比使用const更好

**作用域**：代码块、文件、函数原型、函数作用域

**链接属性**：external、internal和none。static可改变缺省属性为external的声明。extern表示变量的定义在函数外其他的位置。

**存储类型**：静态变量、自动变量、寄存器变量。对代码块内的变量加上关键字static，使其存储类型从自动变量修改为静态变量。

static关键字：修改链接属性，修改变量的存储类型。

## 5种存储类

c使用作用域、链接和存储时期来定义5种存储类：自动存储类、寄存器存储类、具有代码块作用域的静态存储类、具有外部链接的静态存储类，以及具有内部链接的静态存储类。

| 存储类             | 时期 | 作用域 | 链接 | 声明方式       |
| ------------------ | ---- | ------ | ---- | -------------- |
| 自动               | 自动 | 代码块 | 空   | auto(可选)     |
| 寄存器             | 自动 | 代码块 | 空   | register       |
| 具有外部链接的静态 | 静态 | 文件   | 外部 | 所有函数之外   |
| 具有内部链接的静态 | 静态 | 文件   | 内部 | 函数外，static |
| 代码块作用域的静态 | 静态 | 代码块 | 空   | 代码块，static |

## 总结

1. 为保持最佳的移植性，使用char时应该限制在有符号和无符号字符范围的交集，或者不在字符上进行算术运算。
2. 定义类型的别名，使用typedef而不是#define
3. const声明的变量不会修改其值
4. 必须明确使用extern的情况：当需要使用外部文件的变量时
5. static关键字可修改标识符的链接属性，也可在代码块内修改变量的存储类型。



# 第四章 语句

##要点

空语句

表达式语句

代码块

if语句

while语句：break和continue

for语句

do语句

switch语句：default

goto

## 总结

1. 不会产生任何结果的表达式
2. switch语句，执行流从一个case顺延到下一个case
3. for循环的可读性比while强，因为它把用于控制循环的表达式收集起来放在一个地方。

# 第五章 操作符和表达式

## 要点

算术操作符

移位操作符：& | ^, 分别执行AND、OR和XOR操作。

逻辑移位和算术移位，a << -5（避免这种用法）

value = value | 1 << bit_number // 将指定位设为1

value = value

# 第8章 数组

## 要点

一维数组，标量与数组

数组名：**在几乎所有使用数组名的表达式中，数组名是一个指针常量**，也就是第1个元素的地址。但是，不能得出数组和指针是相同的结论，数组具有确定数量的元素，编译器用数组名记住这些属性。在两种场合下，数组名并不表示指针常量，当在sizeof或&运算符中使用时。**理解表达式中数组名的真正含义是非常重要的**。

*(b + 3)的含义：b是数组名，其值是一个指向整型的指针，+3根据整型值的长度进行调整，然后间接访问符访问这个新位置，取得那里的值（右值），或者把一个值存储在该处（左值）。这和下标引用的执行过程完全相同。实际上，**除了优先级外，下标引用和间接访问完全相同**。

下标检查在c中是一项困难的任务，下标引用可以作用于任意的指针，而不仅仅是数组名，对指针进行下标引用的有效性既依赖于指针当时指向什么内容，也依赖于下标的值。2[array],这种古怪的表达式与array[2]是相等的，这缘于C实现下标的方法，对编译器来说，这两种形式并无差别。

指针与下标，指针与下标的效率区别，分析一个实例产生的汇编代码

数组和指针

数组名作为函数的参数

register变量，编译器比程序员更加懂得怎样合理分配寄存器

数组的初始化，不完整的初始化，自动计算数组长度，字符数组的初始化

多维数组，多维数组的存储顺序

多维数组的元素也是一个数组

多维数组的下标访问：下标是从左向右进行计算的，数组名是一个指向第1维第1个元素的指针，所以第1个下标值根据该元素的长度进行调整。它的结果仍然是那1维某个元素的指针。对其解引用（间接访问操作）后是一个指向下一维第1个元素的指针，下一个下标值根据这个长度进行调整，这个过程重复进行，直到所有下标计算完毕。

指向数组的指针：int (*0)[10]

int matrix\[3\]\[10\],matrix并不是一个指向整型的指针，而是一个指向整型数组的指针。

作为函数参数的多维数组

指针数组